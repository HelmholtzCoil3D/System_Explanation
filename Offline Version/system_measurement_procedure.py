'''
This script get the data generated by "system_current_finder.py", form the csv
file, and apply the currents necessary to get the previous calculated field, 
storing the osciloscope data in another csv file, one for each field setting.

@author: Tarcis Becher
'''

#%% Imports

import numpy as np
import csv
from time import sleep
from auxLib import RTB_measurement, RTB_setup, updateCoilPolarity, getDataFromReader, rotationMatrixCalculator, strToFloat, storeDataObj, writeDataOnFile, CurrentCalculatorObj, setField, startupCoilsPolarity, closeFile, closeSerialObj, createAndOpenFile, WhatTimeIsIt, makeDir, createSerialObj, COMdetect, changeCoilPolarity, measurementNtransformation, setPowerSupplyChVoltage, setPowerSupplyAllChVoltage, setPowerSupplyAllChCurrent, setupMCU, closingPowerSupplyChannel, startUpPowerSupply, getMeasurement, setPowerSupplyChCurrent
import visa

#%% User code

# Startup information for the MCU
samplesPerMean = b'2'
timeBetweenSamples = b'100'

# Information about the file to read
csvPath = "./csvData/"
csvFileName = "sohvai"

# Prefix of the osciloscope data files (csv)
fileName = 'FLUXGT'


#%% csv files stuff

# Creating the folder to save data from osciloscope
data = WhatTimeIsIt()
fileDir = "./measurement_"+data[14:16]+data[11:13]+data[0:10]+"/"

# Getting data from current finder results
fileField = csvPath + csvFileName + ".csv"
file = open(fileField, 'r')
reader = csv.reader(file, delimiter=';', quoting=csv.QUOTE_NONE)
floatData, channel, zeroField, rotationMatrixMeasures, control = getDataFromReader(reader, 1)
file.close()

#%% Start up code    

# To show numbers in console in the raw representation
np.set_printoptions(suppress=True)

# Teorethical values for field/current ration
teorethicalRelationship = [0.5, 2.5, 0.5]

try:
    # opening MCU comunication
    COM = COMdetect()
    serialObj = createSerialObj(COM)
        
    # Opening the MCU comunication channel
    setupMCU(serialObj, samplesPerMean, timeBetweenSamples)
    sleep(0.1)
    startupCoilsPolarity(serialObj)
    
    # Opening comunication with the instruments (PowerSupply and Osciloscope)
    resource_name = 'USB0::0x1AB1::0x0E11::DP8A203800261::0::INSTR'       
    rm, dp800 = startUpPowerSupply(resource_name)    
    RTB = rm.open_resource('USB0::0x0AAD::0x01D6::107205::0::INSTR')
    RTB_setup(RTB)
    
    # Rotation matrix to check if the initial field is diferent from the one in the file
    rotationMatrix = rotationMatrixMeasures
       
    # Comparing the zero fields
    setPowerSupplyAllChVoltage(dp800, 4)
    setPowerSupplyAllChCurrent(dp800, 0)
    fData = getMeasurement(serialObj)
    zeroFieldMeasured = np.matmul(rotationMatrix, fData)
    
    '''
    # some analysis data for debugging
    error = [0,0,0]
    for i in range(0,3):
        error [i]= (zeroFieldMeasured[i] - zeroField[i])
    print("zero field absolute diference:")
    print(error)
    '''
    # inicialization of variables
    currents = floatData[3]
    
    '''
    # some analysis data for debugging
    newMeasures = np.zeros((len(currents),3))
    errors= np.zeros((len(currents),3))
    '''
    
    # inicialization of variables
    dp800.write("DISP:MODE NORM")
    sleep(0.01)
    i = 0
    indexSum = 1
    fields = floatData[1]
    
    # Loop to apply all the calculated currents
    while(i<len(currents)):
        
        # If the field was calculated in current or voltage mode, it applies the right value to the right parameter
        if str(control[i]) == "['Current']":
            #print(currents[i])
            updateCoilPolarity(serialObj, currents[i], channel[i])
            setPowerSupplyChCurrent(dp800, channel[i], float(currents[i]/1000))
            setPowerSupplyChVoltage(dp800, channel[i], 4)
        else:
            updateCoilPolarity(serialObj, currents[i], channel[i])
            setPowerSupplyChVoltage(dp800, channel[i], float(currents[i]/1000))
            setPowerSupplyChCurrent(dp800, channel[i], 0.5)
        # Some realtime checking prints
        print(fields[i])
        print(i)
        
        # Create the files that will have the voltage/time data for later analysis
        if i>2:
            # Create dir of the file
            makeDir(fileDir)
            # Create file and open it
            fileCsv = createAndOpenFile(fileDir, fileName + str(i) , ".csv")
            # get data from osciloscope
            dataVector = RTB_measurement(RTB)
            # Field value is the first information
            fileCsv.write(str(fields[i])+";\n")
            
            # Write all the data in a CSV file
            for j in range(0,len(dataVector)):
                fileCsv.write(str(dataVector[j]))
                fileCsv.write(";\n")
            # Closes the file
            fileCsv.close()
            
        '''
        fData = getMeasurement(serialObj)
        fData = np.matmul(rotationMatrix, fData)
        for j in range(0,3):
            newMeasures[i][j] = fData[j]
            errors[i][j] = newMeasures[i][j] - floatData[j][i]
        '''   
        i += indexSum
        
    '''
    print('absolute diference between measured field and expected field:')
    print(errors)
    print('absolute measured field:')
    print(newMeasures)
    '''
    # Close comunications
    closeSerialObj(serialObj)
    closingPowerSupplyChannel(dp800, rm)
    RTB.close()
    
except Exception as error:
    print(error)
    
    # Close comunications
    closeSerialObj(serialObj)
    closingPowerSupplyChannel(dp800, rm)
    RTB.close()